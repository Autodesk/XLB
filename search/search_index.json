{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"XLB's home","text":""},{"location":"#xlb-a-differentiable-massively-parallel-lattice-boltzmann-library-in-python-for-physics-based-machine-learning","title":"XLB: A Differentiable Massively Parallel Lattice Boltzmann Library in Python for Physics-Based Machine Learning","text":"<p>\ud83c\udf89 Exciting News! \ud83c\udf89 XLB version 0.2.0 has been released, featuring a complete rewrite of the library and introducing support for the NVIDIA Warp backend!  XLB can now be installed via pip: <code>pip install xlb</code>.</p> <p>XLB is a fully differentiable 2D/3D Lattice Boltzmann Method (LBM) library that leverages hardware acceleration. It supports JAX and NVIDIA Warp backends, and is specifically designed to solve fluid dynamics problems in a computationally efficient and differentiable manner. Its unique combination of features positions it as an exceptionally suitable tool for applications in physics-based machine learning. With the new Warp backend, XLB now offers state-of-the-art performance for even faster simulations.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To get started with XLB, you can install it using pip:</p> <pre><code>pip install xlb\n</code></pre> <p>To install the latest development version from source:</p> <pre><code>pip install git+https://github.com/Autodesk/XLB.git\n</code></pre> <p>The changelog for the releases can be found here.</p> <p>For examples to get you started please refer to the examples folder.</p>"},{"location":"#accompanying-paper","title":"Accompanying Paper","text":"<p>Please refer to the accompanying paper for benchmarks, validation, and more details about the library.</p>"},{"location":"#citing-xlb","title":"Citing XLB","text":"<p>If you use XLB in your research, please cite the following paper:</p> <pre><code>@article{ataei2024xlb,\n  title={{XLB}: A differentiable massively parallel lattice {Boltzmann} library in {Python}},\n  author={Ataei, Mohammadmehdi and Salehipour, Hesam},\n  journal={Computer Physics Communications},\n  volume={300},\n  pages={109187},\n  year={2024},\n  publisher={Elsevier}\n}\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Multiple Backend Support: XLB now includes support for multiple backends including JAX and NVIDIA Warp, providing state-of-the-art performance for lattice Boltzmann simulations. Currently, only single GPU is supported for the Warp backend.</li> <li>Integration with JAX Ecosystem: The library can be easily integrated with JAX\u2019s robust ecosystem of machine learning libraries such as Flax, Haiku, Optax, and many more.</li> <li>Differentiable LBM Kernels: XLB provides differentiable LBM kernels that can be used in differentiable physics and deep learning applications.</li> <li>Scalability: XLB is capable of scaling on distributed multi-GPU systems using the JAX backend, enabling the execution of large-scale simulations on hundreds of GPUs with billions of cells.</li> <li>Support for Various LBM Boundary Conditions and Kernels: XLB supports several LBM boundary conditions and collision kernels.</li> <li>User-Friendly Interface: Written entirely in Python, XLB emphasizes a highly accessible interface that allows users to extend the library with ease and quickly set up and run new simulations.</li> <li>Leverages JAX Array and Shardmap: The library incorporates the new JAX array unified array type and JAX shardmap, providing users with a numpy-like interface. This allows users to focus solely on the semantics, leaving performance optimizations to the compiler.</li> <li>Platform Versatility: The same XLB code can be executed on a variety of platforms including multi-core CPUs, single or multi-GPU systems, TPUs, and it also supports distributed runs on multi-GPU systems or TPU Pod slices.</li> <li>Visualization: XLB provides a variety of visualization options including in-situ on GPU rendering using PhantomGaze.</li> </ul>"},{"location":"#showcase","title":"Showcase","text":"<p>   On GPU in-situ rendering using PhantomGaze library (no I/O). Flow over a NACA airfoil using KBC Lattice Boltzmann Simulation with ~10 million cells. </p> <p> </p> <p>  DrivAer model  in a wind-tunnel using KBC Lattice Boltzmann Simulation with approx. 317 million cells </p> <p> </p> <p>   Airflow in to, out of, and within a building (~400 million cells) </p> <p> </p> <p> The stages of a fluid density field from an initial state to the emergence of the \"XLB\" pattern through deep learning optimization at timestep 200 (see paper for details) </p> <p></p> <p> </p> <p>   Lid-driven Cavity flow at Re=100,000 (~25 million cells) </p>"},{"location":"#capabilities","title":"Capabilities","text":""},{"location":"#lbm","title":"LBM","text":"<ul> <li>BGK collision model (Standard LBM collision model)</li> <li>KBC collision model (unconditionally stable for flows with high Reynolds number)</li> </ul>"},{"location":"#machine-learning","title":"Machine Learning","text":"<ul> <li>Easy integration with JAX\u2019s ecosystem of machine learning libraries</li> <li>Differentiable LBM kernels</li> <li>Differentiable boundary conditions</li> </ul>"},{"location":"#lattice-models","title":"Lattice Models","text":"<ul> <li>D2Q9</li> <li>D3Q19</li> <li>D3Q27 (Must be used for KBC simulation runs)</li> </ul>"},{"location":"#compute-capabilities","title":"Compute Capabilities","text":"<ul> <li>Single GPU support for the Warp backend with state-of-the-art performance</li> <li>Distributed Multi-GPU support using the JAX backend</li> <li>Mixed-Precision support (store vs compute)</li> <li>Out-of-core support (coming soon)</li> </ul>"},{"location":"#output","title":"Output","text":"<ul> <li>Binary and ASCII VTK output (based on PyVista library)</li> <li>In-situ rendering using PhantomGaze library</li> <li>Orbax-based distributed asynchronous checkpointing</li> <li>Image Output</li> <li>3D mesh voxelizer using trimesh</li> </ul>"},{"location":"#boundary-conditions","title":"Boundary conditions","text":"<ul> <li> <p>Equilibrium BC: In this boundary condition, the fluid populations are assumed to be in at equilibrium. Can be used to set prescribed velocity or pressure.</p> </li> <li> <p>Full-Way Bounceback BC: In this boundary condition, the velocity of the fluid populations is reflected back to the fluid side of the boundary, resulting in zero fluid velocity at the boundary.</p> </li> <li> <p>Half-Way Bounceback BC: Similar to the Full-Way Bounceback BC, in this boundary condition, the velocity of the fluid populations is partially reflected back to the fluid side of the boundary, resulting in a non-zero fluid velocity at the boundary.</p> </li> <li> <p>Do Nothing BC: In this boundary condition, the fluid populations are allowed to pass through the boundary without any reflection or modification.</p> </li> <li> <p>Zouhe BC: This boundary condition is used to impose a prescribed velocity or pressure profile at the boundary.</p> </li> <li>Regularized BC: This boundary condition is used to impose a prescribed velocity or pressure profile at the boundary. This BC is more stable than Zouhe BC, but computationally more expensive.</li> <li> <p>Extrapolation Outflow BC: A type of outflow boundary condition that uses extrapolation to avoid strong wave reflections.</p> </li> <li> <p>Interpolated Bounceback BC: Interpolated bounce-back boundary condition for representing curved boundaries.</p> </li> </ul>"},{"location":"#roadmap","title":"Roadmap","text":""},{"location":"#work-in-progress-wip","title":"Work in Progress (WIP)","text":"<p>Note: Some of the work-in-progress features can be found in the branches of the XLB repository. For contributions to these features, please reach out.</p> <ul> <li> <p>\ud83c\udf10 Grid Refinement: Implementing adaptive mesh refinement techniques for enhanced simulation accuracy.</p> </li> <li> <p>\ud83d\udcbe Out-of-Core Computations: Enabling simulations that exceed available GPU memory, suitable for CPU+GPU coherent memory models such as NVIDIA\u2019s Grace Superchips (coming soon).</p> </li> <li> <p>\u26a1 Multi-GPU Acceleration using Neon + Warp: Using Neon\u2019s data structure for improved scaling.</p> </li> <li> <p>\ud83d\udddc\ufe0f GPU Accelerated Lossless Compression and Decompression: Implementing high-performance lossless compression and decompression techniques for larger-scale simulations and improved performance.</p> </li> <li> <p>\ud83c\udf21\ufe0f Fluid-Thermal Simulation Capabilities: Incorporating heat transfer and thermal effects into fluid simulations.</p> </li> <li> <p>\ud83c\udfaf Adjoint-based Shape and Topology Optimization: Implementing gradient-based optimization techniques for design optimization.</p> </li> <li> <p>\ud83e\udde0 Machine Learning Accelerated Simulations: Leveraging machine learning to speed up simulations and improve accuracy.</p> </li> <li> <p>\ud83d\udcc9 Reduced Order Modeling using Machine Learning: Developing data-driven reduced-order models for efficient and accurate simulations.</p> </li> </ul>"},{"location":"#wishlist","title":"Wishlist","text":"<p>Contributions to these features are welcome. Please submit PRs for the Wishlist items.</p> <ul> <li> <p>\ud83c\udf0a Free Surface Flows: Simulating flows with free surfaces, such as water waves and droplets.</p> </li> <li> <p>\ud83d\udce1 Electromagnetic Wave Propagation: Simulating the propagation of electromagnetic waves.</p> </li> <li> <p>\ud83d\udee9\ufe0f Supersonic Flows: Simulating supersonic flows.</p> </li> <li> <p>\ud83c\udf0a\ud83e\uddf1 Fluid-Solid Interaction: Modeling the interaction between fluids and solid objects.</p> </li> <li> <p>\ud83e\udde9 Multiphase Flow Simulation: Simulating flows with multiple immiscible fluids.</p> </li> <li> <p>\ud83d\udd25 Combustion: Simulating combustion processes and reactive flows.</p> </li> <li> <p>\ud83e\udea8 Particle Flows and Discrete Element Method: Incorporating particle-based methods for granular and particulate flows.</p> </li> <li> <p>\ud83d\udd27 Better Geometry Processing Pipelines: Improving the handling and preprocessing of complex geometries for simulations.</p> </li> </ul>"}]}